# 默克尔前缀树
## 0 默克尔树
### 0.1特点
1. 默克尔树是一种树，大多数是二叉树，也可以多叉树，无论是几叉树，它都具有树结构的所有特点；

2.  默克尔树叶子节点的value是数据项的内容，或者是数据项的哈希值；

3. 非叶子节点的value根据其孩子节点的信息，然后按照Hash算法计算而得出的。

### 0.2 原理
在比特币网络中，merkle树是自底向上构建的，如下图所示：

![image](https://user-images.githubusercontent.com/105578152/181407089-4306e26a-0d3d-48ca-a2de-5e88f7d76f47.png)

将相邻两个节点的哈希值合并成一个字符串，然后计算这个字符串的哈希，得到的就是这两个节点的父节点的哈希值。若两棵树的根哈希一致，则这两棵树的结构、节点的内容必然相同。

### 0.3 优势

1. 快速重哈希
默克尔树的特点之一就是当树节点内容发生变化时，能够在前一次哈希计算的基础上，仅仅将被修改的树节点进行哈希重计算，便能得到一个新的根哈希用来代表整棵树的状态。

2. 轻节点扩展
采用默克尔树，可以在公链环境下扩展一种“轻节点”。轻节点的特点是对于每个区块，仅仅需要存储约80个字节大小的区块头数据，而不存储交易列表，回执列表等数据。然而通过轻节点，可以实现在非信任的公链环境中验证某一笔交易是否被收录在区块链账本的功能。这使得像比特币，以太坊这样的区块链能够运行在个人PC，智能手机等拥有小存储容量的终端上。

### 0.4 劣势

存储空间开销大
## 1 原理介绍
### 1.1 概述
默克尔前缀树，也称为默克尔树（Merkle Tree），是一种在密码学和计算机科学中常用的数据结构，用于验证和确保数据的完整性。它是由计算机科学家拉尔夫·默克尔于1979年引入的，用于支持分布式系统中的数据验证。

默克尔前缀树基于二叉树的结构，但具有一些特殊的性质，使得它在验证大量数据的完整性方面非常高效。

### 1.2 节点分类
- 扩展节点（Extension Node）：只能有一个子节点。
- 分支节点（Branch Node）：可以有多个节点。
- 叶子节点（Leaf Node）：没有子节点。
- 空节点：空字符串。 叶子节点和扩展节点
```
type shortNode struct {
        Key   []byte
        Val   node
        flags nodeFlag
}
```
Key：用来存储属于该节点范围的key，Val：用来存储该节点的内容；
### 空节点
空节点用来表示空串。

### 分支节点
分支节点用来表示MPT树中所有拥有超过1个孩子节点以上的非叶子节点

与前缀树相同，MPT同样是把key-value数据项的key编码在树的路径中，但是key的每一个字节值的范围太大（[0-127]），因此在以太坊中，在进行树操作之前，首先会进行一个key编码的转换，将一个字节的高低四位内容分拆成两个字节存储。通过编码转换，key’的每一位的值范围都在[0, 15]内。因此，一个分支节点的孩子至多只有16个。以太坊通过这种方式，减小了每个分支节点的容量，但是在一定程度上增加了树高。

分支节点的孩子列表中，最后一个元素是用来存储自身的内容。

此外，每个分支节点会有一个附带的字段nodeFlag，记录了一些辅助数据：

1. 节点哈希：若该字段不为空，则当需要进行哈希计算时，可以跳过计算过程而直接使用上次计算的结果（当节点变脏时，该字段被置空）；

2. 脏标志：当一个节点被修改时，该标志位被置为1；

3. 诞生标志：当该节点第一次被载入内存中（或被修改时），会被赋予一个计数值作为诞生标志，该标志会被作为节点驱除的依据，清除内存中“太老”的未被修改的节点，防止占用的内存空间过多。

### 叶子节点&&扩展节点

关键的字段为：

1. Key：用来存储属于该节点范围的key，这是MPT树实现树高压缩的关键；

2. Val：用来存储该节点的内容；

如之前所提及的，前缀树中会出现严重的存储空间浪费的情况，如下图：

![image](https://user-images.githubusercontent.com/105578152/181411332-0cdf8f00-fccf-4545-b301-9a20dfa054e4.png)


针对这种情况，MPT树对此进行了优化：当MPT试图插入一个节点，插入过程中发现目前没有与该节点Key拥有相同前缀的路径。此时MPT把剩余的Key存储在叶子／扩展节点的Key字段中，充当一个”Shortcut“。

这种做法可以提高节点的查找效率，避免过多的磁盘访问，并且减少存储空间浪费，避免存储无用的节点。

## 2 具体操作
- 插入（Insertion）：向MPT中插入一个新的键值对。通常，这用于将账户地址与其状态相关联，或将交易信息与块号相关联。插入过程会导致MPT的结构发生变化，可能需要更新多个节点。

- 删除（Deletion）：从MPT中删除一个键值对。这在区块链中一般不会直接删除数据，而是将其标记为不可用或者设置为某种默认状态。删除操作也可能导致MPT的结构发生变化。

- 更新（Update）：更新MPT中的某个键对应的值。与插入操作类似，更新操作也可能导致结构的变化。

- 查询（Query）：查询MPT中特定键对应的值。这是通过从根节点开始按照键的每一位的路径向下查找实现的。

- 根哈希计算：计算整个MPT的根哈希。这个根哈希能够唯一地表示当前MPT中的所有数据。

- 验证：验证MPT中的某个键值对是否存在，以及根哈希是否与预期一致。这在确保账户状态的完整性方面是至关重要的。

下面具体介绍一些操作的细节
### 2.1 Query
将需要查找Key的Raw编码转换成Hex编码，得到的内容称之为搜索路径，从根节点开始搜寻与搜索路径内容一致的路径；

1. 若当前节点为叶子节点，存储的内容是数据项的内容，且搜索路径的内容与叶子节点的key一致，则表示找到该节点；反之则表示该节点在树中不存在。

2. 若当前节点为扩展节点，且存储的内容是哈希索引，则利用哈希索引从数据库中加载该节点，再将搜索路径作为参数，对新解析出来的节点递归地调用查找函数。

3. 若当前节点为扩展节点，存储的内容是另外一个节点的引用，且当前节点的key是搜索路径的前缀，则将搜索路径减去当前节点的key，将剩余的搜索路径作为参数，对其子节点递归地调用查找函数；若当前节点的key不是搜索路径的前缀，表示该节点在树中不存在。

4. 若当前节点为分支节点，若搜索路径为空，则返回分支节点的存储内容；反之利用搜索路径的第一个字节选择分支节点的孩子节点，将剩余的搜索路径作为参数递归地调用查找函数。

![image](https://user-images.githubusercontent.com/105578152/181409519-c8fa35a8-994c-4cab-8e12-0debcf126060.png)

### 2.2 Insert
插入操作也是基于查找过程完成的，一个插入过程为：

1. 首先找到与新插入节点拥有最长相同路径前缀的节点，记为Node；

2. 若该Node为分支节点：

- 剩余的搜索路径不为空，则将新节点作为一个叶子节点插入到对应的孩子列表中；

* 剩余的搜索路径为空（完全匹配），则将新节点的内容存储在分支节点的第17个孩子节点项中（Value）；

3. 若该节点为叶子／扩展节点：

* 剩余的搜索路径与当前节点的key一致，则把当前节点Val更新即可；

* 剩余的搜索路径与当前节点的key不完全一致，则将叶子／扩展节点的孩子节点替换成分支节点，将新节点与当前节点key的共同前缀作为当前节点的key，将新节点与当前节点的孩子节点作为两个孩子插入到分支节点的孩子列表中，同时当前节点转换成了一个扩展节点（若新节点与当前节点没有共同前缀，则直接用生成的分支节点替换当前节点）；

4. 若插入成功，则将被修改节点的dirty标志置为true，hash标志置空（之前的结果已经不可能用），且将节点的诞生标记更新为现在。
![image](https://user-images.githubusercontent.com/105578152/181409689-d84ce053-f085-4c40-a6b0-9063e21a6714.png)

### 2.3 Delete
删除操作与插入操作类似，都需要借助查找过程完成，一次删除过程为：

1. 找到与需要插入的节点拥有最长相同路径前缀的节点，记为Node；

2. 若Node为叶子／扩展节点：

* 若剩余的搜索路径与node的Key完全一致，则将整个node删除；

* 若剩余的搜索路径与node的key不匹配，则表示需要删除的节点不存于树中，删除失败；

* 若node的key是剩余搜索路径的前缀，则对该节点的Val做递归的删除调用；

3. 若Node为分支节点：

*  删除孩子列表中相应下标标志的节点；

*  删除结束，若Node的孩子个数只剩下一个，那么将分支节点替换成一个叶子／扩展节点；

4. 若删除成功，则将被修改节点的dirty标志置为true，hash标志置空（之前的结果已经不可能用），且将节点的诞生标记更新为现在。
![image](https://user-images.githubusercontent.com/105578152/181409812-d5c731c8-4b04-49fa-a599-142dc536f454.png)

## 3 应用
MTP有许多具体的应用，下面列举了一部分：

1. 以太坊账户状态存储：以太坊使用MPT来存储账户状态。每个以太坊账户都有一个与之相关联的状态，包括余额、代码和存储数据。MPT能够高效地存储和更新这些状态，使得验证账户的完整性变得高效且可靠。

3. 交易存储：区块链中的交易通常会被存储在MPT中。通过将交易与块号相关联，MPT可以帮助快速检索交易，同时确保交易数据的完整性。

5. 区块头存储：区块链中的每个区块头通常都包含了一些元信息，如时间戳、难度、前一个区块的哈希等。MPT可以用于高效地存储和验证这些元信息。

7. 智能合约状态存储：类似于以太坊账户，智能合约也有状态，包括合约代码和存储数据。MPT可以被用来存储智能合约的状态，以实现高效的状态管理和验证。

9. 证书路径验证：在加密领域，MPT可以被用来存储和验证数字证书的证书路径。这可以帮助快速验证数字证书的有效性，而无需查看整个证书链。

## 参考文献
https://blog.csdn.net/qq_40713201/article/details/124486307?ops_request_misc=%257B%2522request%255Fid%2522%253A%2522165897398016782390545065%2522%252C%2522scm%2522%253A%252220140713.130102334..%2522%257D&request_id=165897398016782390545065&biz_id=0&utm_medium=distribute.pc_search_result.none-task-blog-2~all~sobaiduend~default-1-124486307-null-null.142^v35^experiment_2_v1,185^v2^control&utm_term=MPT&spm=1018.2226.3001.4187
