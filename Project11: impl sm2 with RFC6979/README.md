# SM2实现
## 1 原理介绍
SM2（国密算法2）是中国密码领域推出的一种基于椭圆曲线密码学的非对称加密算法。它被设计用来替代传统的RSA和DSA算法，在数字签名、密钥交换等安全通信场景中使用。

SM2基于椭圆曲线密码学，利用椭圆曲线上的点运算来实现非对称加密和数字签名。与传统RSA算法相比，椭圆曲线算法在相同的安全性要求下，需要更短的密钥长度，从而提高了效率。

 SM2提供了两种主要的密码体制：数字签名和密钥交换。它支持消息的完整性、机密性和不可否认性。SM2使用的椭圆曲线参数选择较小，因此其密钥长度相对较短，通常为256位。相比之下，RSA算法需要更长的密钥长度来达到相同的安全性，这导致RSA在加密和签名操作上的效率相对较低。

由于SM2采用了较短的密钥长度，因此在相同的加密强度下，其加解密速度和签名/验证速度相对于传统的RSA算法更快。SM2在中国国内得到广泛应用，特别是在政府、金融、电子身份认证等领域。然而，在国际上，由于SM2是中国自主研发的算法，其在全球范围内的应用相对较少。

签名过程如图：
![](https://pic4.zhimg.com/80/v2-42963f5dc530692de316f773bd5faae7_1440w.webp)
验证过程如图：
![](https://pic2.zhimg.com/80/v2-9c74c7eb8f6df57023a406b2e47d3259_1440w.webp)
## 2 代码分析
代码分为以下几个部分
1. 导入模块：
- secrets：用于生成随机的私钥和随机数。
- hashlib 中的 sha256：用于计算 SHA-256 哈希。
- gmssl 中的 sm3 和 func：用于计算 SM3 哈希。
2. 椭圆曲线参数：定义了椭圆曲线的参数，包括椭圆曲线的方程、素数 P、基点 G 等。

3. 一系列椭圆曲线运算函数：
- LegendreSymbol(y, p)：计算勒让德符号。
- TonelliShanks(y, p)：Tonelli-Shanks 算法，用于求解模素数情况下的平方根。
- extended_euclidean(j, k)：扩展欧几里得算法，用于计算两个数的最大公约数以及相关的系数。
- mod_inverse(j, n)：计算模逆。
- elliptic_add(p, q)：椭圆曲线点加法。
- elliptic_double(p)：椭圆曲线点的倍乘运算。
- elliptic_multiply(s, p)：椭圆曲线点的标量倍乘。
4. get_bit_length(x) 函数：用于计算整数、字符串或字节的位长度。
5. precompute(ID, a, b, G_X, G_Y, x_A, y_A) 函数：预计算用于签名的值。
6. generate_key() 函数：生成私钥和对应的公钥。
4. sign(private_key, message, Z_A) 函数：用私钥对消息进行签名。
5. verify(public_key, ID, message, signature) 函数：验证签名的有效性。
## 3 运行结果
最终成功运行
![](https://img1.imgtp.com/2023/08/03/5CrHJV1m.png)