# MerkleTree
## 1 原理分析
### 1.1 MerkleTree介绍
Merkle Tree 本身也算是一个哈希列表，只不过是在这个基础上又引入了树形结构，从而获得了更高的灵活性。

在最底层，和哈希列表一样，通过把数据分成小的数据块，有相应的哈希和它对应。但是往上走，并不是直接去运算根哈希，而是把相邻的两个哈希合并成一个字符串，然后运算这个字符串的哈希，这样每两个哈希就结婚生子，得到了一个”子哈希“。如果最底层的哈希总数是单数，那到最后必然出现一个单身哈希，这种情况就直接对它进行哈希运算，所以也能得到它的子哈希。于是往上推，依然是一样的方式，可以得到数目更少的新一级哈希，最终必然形成一棵倒挂的树，到了树根的这个位置，这一代就剩下一个根哈希了，我们把它叫做 Merkle Root 。需要补充一下的是，根哈希有时候也叫主哈希 Master Hash ，也有人叫它顶哈希 Top Hash ，因为画图的时候通常都是倒着画这根树，反正不管叫什么，说的都是一个东西。
![](https://pic2.zhimg.com/80/v2-a3fccf44b48106dba7bd53368eb3674d_1440w.webp)
### 1.2 设计原理
* 将待验证的数据划分为固定大小的数据块（通常是2的幂次方），每个数据块都有一个唯一的哈希值。
* 将相邻的两个数据块进行哈希计算，并将结果合并为一个新的哈希值。这个过程称为哈希合并。
* 重复步骤2，直到最终只剩下一个根哈希值，称为树根。这个树根即为整个数据集的唯一表示。
* 在验证数据完整性时，如果需要验证某个数据块是否被篡改，只需从该数据块开始，逐级向上计算哈希值，直到树根。然后可以比较树根与预先保存的正确的树根值是否相同。
## 2 代码分析
功能函数定义：
- calculate_hash(data): 计算给定数据的 SHA-256 哈希值。
- concatenate_zero(data): 将数据与前缀 0 进行拼接，用于表示左子叶子节点。
- concatenate_one(data1, data2): 将两个数据进行拼接，用于表示右子叶子节点。

MerkleTree 类：
- init(self, data): 初始化 Merkle 树，接收叶子节点数据，调用 build_merkle_tree 构建树。
- build_merkle_tree(self): 构建 Merkle 树，计算根哈希值和叶子节点位置信息。
- audit_path(self, m, leaves): 生成某个叶子节点的审核路径。
- compute_merkle_tree_hash(self, leaves): 计算 Merkle 树的哈希值。
- membership_proof(self, m, leaf): 验证成员存在性的证明。
- test_merkle_tree(length): 测试 Merkle 树的构建和验证。

主程序部分：
* 通过 test_merkle_tree(100000) 测试了生成 100000 个节点的 Merkle 树。

创建了一个包含 5 个节点的 Merkle 树实例 ex，并验证叶子节点 '2' 是否存在于树中。
该代码实现了 Merkle 树的构建和验证功能，通过对叶子节点进行哈希计算、构建树结构以及生成审核路径，可以验证某个叶子节点是否存在于 Merkle 树中。这类数据结构在加密货币、区块链等领域中具有重要应用，用于保障数据的安全性和完整性。

## 运行结果
![](https://img1.imgtp.com/2023/08/02/Ip7yuU0C.png)